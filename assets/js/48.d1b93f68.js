(window.webpackJsonp=window.webpackJsonp||[]).push([[48],{459:function(e,t,a){"use strict";a.r(t);var i=a(22),r=Object(i.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"why-does-pojavlauncher-require-jailbreak"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#why-does-pojavlauncher-require-jailbreak"}},[e._v("#")]),e._v(" Why does PojavLauncher require jailbreak?")]),e._v(" "),a("p",[e._v("On iOS/iPadOS, every executable needs to be signed or trustcached while having\nan adhoc signature. Additionally, the memory pages of the processes must also be\nbacked with a signature when they are executed given that they do not have the\n"),a("code",[e._v("dynamic-codesigning")]),e._v(" entitlement (which cannot be normmally obtained while\njailed) or has the "),a("code",[e._v("get-task-allow")]),e._v(" entitlements and has "),a("code",[e._v("CS_DEBUGGED")]),e._v(" set on\nit, else the process gets terminated while trying to do it.  Additionally, the\n"),a("code",[e._v("dynamic-codesigning")]),e._v(" entitlement is required to create memory pages that are\nboth readable, writable and executable. PojavLauncher uses JIT (Just-In-Time)\ncompliation for in java to improve performance, which is used to run minecraft.\nA JIT compiler emits instructions at runtime and then exeute them. This do not\nwork jailed because you can only have readable-executable and readable-writable\nmemory pages. Although it is possible to switch the permissions back and forth\nor map some pages readable-writable, then mirror-map them as\nreadable-executable, JIT compilation still will not work due to these pages\nbeing unsigned.")]),e._v(" "),a("h2",{attrs:{id:"methods-considered"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#methods-considered"}},[e._v("#")]),e._v(" Methods considered")]),e._v(" "),a("h3",{attrs:{id:"using-zero-vm"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#using-zero-vm"}},[e._v("#")]),e._v(" Using Zero VM")]),e._v(" "),a("p",[e._v("This is commonly confused with "),a("code",[e._v("-Xint")]),e._v(" although this is actually worse than\nthat. In a Zero VM, there is no JIT compliation. Everything is interptered. This\ncan work jailed. However, the performance will be so bad that it is better\nmeasured in seconds per frame instead of frames per seconds! Therefore this will\nnot really work.")]),e._v(" "),a("h3",{attrs:{id:"using-threaded-interpter-fake-jit"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#using-threaded-interpter-fake-jit"}},[e._v("#")]),e._v(' Using threaded interpter/"fake JIT"')]),e._v(" "),a("p",[e._v('In a threaded interpter, all the possible "JIT" results are pre-compiled. At\nruntime, the threaded interpter generates ("JIT") memory pointers to the\nprecompiled code in memory and have the CPU execute that. Since all the code\nexecuted is pre-compiled and therefore signed, this can work jaied. The\nperformance is much better than a normal interpter while being sigificantly\nworse than a JIT compiler. However, java has no threaded interpreter backend so\nit needs to be implemented from scratch, and the performance is actually still\nquite bad compared to JIT, so this does not really work either.')]),e._v(" "),a("h3",{attrs:{id:"using-psychcic-paper"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#using-psychcic-paper"}},[e._v("#")]),e._v(" Using psychcic_paper")]),e._v(" "),a("p",[e._v("psychic_paper is a bug from at least iOS 11 up to iOS/iPadOS 13.5 beta 2 that\nallows obtaining arbitary entitlements. However, these versions already have\njailbreaks.")]),e._v(" "),a("h3",{attrs:{id:"using-ptrace-trick"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#using-ptrace-trick"}},[e._v("#")]),e._v(" Using ptrace() trick")]),e._v(" "),a("p",[e._v("This works up until iOS/iPadOS 13.7. Basically up until iOS/iPadOS 13.7, a\nprocess can set "),a("code",[e._v("CS_DEBUGGED")]),e._v(" on itself by calling "),a("code",[e._v("ptrace()")]),e._v(" with\n"),a("code",[e._v("PT_TRACE_ME")]),e._v('. This allows a readable-writable mirror map readable-executable\n"bullproof" JIT to be set up.  However, if the process terminated for whatever\nreason other than itself calling '),a("code",[e._v("exit()")]),e._v(", the app will be unusable until a\nreboot due to an iOS bug. Additionally, these versions already have a jailbreak.")]),e._v(" "),a("h3",{attrs:{id:"cs-execseg-allow-unsigned-bug"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cs-execseg-allow-unsigned-bug"}},[e._v("#")]),e._v(" CS_EXECSEG_ALLOW_UNSIGNED bug")]),e._v(" "),a("p",[e._v("This is a flag that can be set while installing the app. On iOS/iPadOS 14.2-14.3\nthis allows for bullproof JIT to happen regardless of an a debugger being\nattached. However, these versions already have jailbreaks.")]),e._v(" "),a("h3",{attrs:{id:"using-webassembly-jit"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#using-webassembly-jit"}},[e._v("#")]),e._v(" Using WebAssembly JIT")]),e._v(" "),a("p",[e._v('In this case, the JIT compiler is made to emit WebAssembly where it will be JIT\ncompiled again into native code by WebKit. However, the delay is high as this\ninvolves inter-process communication. Addtionally, since this is "double-JIT"\nthe performance would not be as good. This is also unimplemented in java.')]),e._v(" "),a("h3",{attrs:{id:"run-with-debugger"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#run-with-debugger"}},[e._v("#")]),e._v(" Run with debugger")]),e._v(" "),a("p",[e._v("This can work for bulletproof JIT, even with latest iOS/iPadOS, tethered with a\ndebugger from another device ("),a("a",{attrs:{href:"https://github.com/osy/jitterbug",target:"_blank",rel:"noopener noreferrer"}},[e._v("JitterBug"),a("OutboundLink")],1),e._v(")/PC\n(AltJIT/libimobiledevice). This is not convenient. This can also be\nsemi-untehered with JitterBug when signed with network extension entitlement\nwith a paid developer account (or when signed with a testflight certificate).\nThe performance will be slightly worse, and you cannot modify jetsam but\niOS/iPadOS has a bug where mirror mapped memory is also considered actual memory\nusage. (Although this can be worked around by not remapping all at once)\nHowever, support for jailed debugger JIT is not implemented into PojavLauncher.")])])}),[],!1,null,null,null);t.default=r.exports}}]);